
---

## ðŸ§  Short answer

> **You specify the exact template by its file path.**

Each reusable workflow is selected by **repo + path + version**.

---

## âœ… How you choose *which* template to run

Given this templates repo:

```text
ci-templates/
â””â”€â”€ .github/workflows/
    â”œâ”€â”€ node-ci.yml
    â”œâ”€â”€ docker-build.yml
    â””â”€â”€ terraform-apply.yml
```

You choose **one specific file** like this:

```yaml
jobs:
  apply:
    uses: my-org/ci-templates/.github/workflows/terraform-apply.yml@v1
```

Thatâ€™s it.

No ambiguity.
No â€œdefault templateâ€.
No magic.

---

## ðŸ§© Why this works so cleanly

* Each `.yml` file is a **separate reusable workflow**
* GitHub does **not** load the whole repo
* It resolves **exactly one file**
* The rest are ignored

Think of it like:

```python
from ci_templates.terraform_apply import run
```

---

## ðŸ§  What happens under the hood

GitHub does this:

1. Fetch repo `my-org/ci-templates`
2. Checkout tag `v1`
3. Load `.github/workflows/terraform-apply.yml`
4. Execute it as a job

Nothing else in the repo matters.

---

## ðŸ§ª Multiple templates from the same repo (common pattern)

In one calling workflow you can mix and match:

```yaml
jobs:
  validate:
    uses: my-org/ci-templates/.github/workflows/terraform-plan.yml@v1

  apply:
    needs: validate
    uses: my-org/ci-templates/.github/workflows/terraform-apply.yml@v1
```

Same repo
Same version
Different templates

---

## âš ï¸ Important constraint (donâ€™t trip on this)

You **cannot** dynamically choose the file name:

```yaml
uses: my-org/ci-templates/.github/workflows/${{ vars.TEMPLATE }}.yml@v1  âŒ
```

The path must be **static**.

This is intentional (security + predictability).

---

## ðŸ§  Best-practice naming (this helps a LOT)

Use **explicit, action-based names**:

```text
terraform-plan.yml
terraform-apply.yml
node-ci.yml
docker-build.yml
```

Avoid:

* `main.yml`
* `ci.yml`
* `pipeline.yml`

Clarity > cleverness.

---

## ðŸ Final takeaway

> **Reusable workflow selection is path-based, not config-based.**

* One repo
* Many templates
* One file = one workflow
* You pick it by name

Thatâ€™s why this model scales so well.

---

